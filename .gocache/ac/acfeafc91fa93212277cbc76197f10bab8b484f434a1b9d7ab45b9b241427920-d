// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/parkmin/go/pkg/mod/github.com/go-gl/glfw/v3.3/glfw@v0.0.0-20240506104042-037f3cc74f2a/vulkan.go:1:1
package glfw

/*
#include "glfw/src/internal.h"

GLFWAPI VkResult glfwCreateWindowSurface(VkInstance instance, GLFWwindow* window, const VkAllocationCallbacks* allocator, VkSurfaceKHR* surface);
GLFWAPI GLFWvkproc glfwGetInstanceProcAddress(VkInstance instance, const char* procname);

// Helper function for doing raw pointer arithmetic
static inline const char* getArrayIndex(const char** array, unsigned int index) {
	return array[index];
}

void* getVulkanProcAddr() {
	return glfwGetInstanceProcAddress;
}
*/
import _ "unsafe"
import (
	"errors"
	"fmt"
	"reflect"
	"unsafe"
)

// VulkanSupported reports whether the Vulkan loader has been found. This check is performed by Init.
//
// The availability of a Vulkan loader does not by itself guarantee that window surface creation or
// even device creation is possible. Call GetRequiredInstanceExtensions to check whether the
// extensions necessary for Vulkan surface creation are available and GetPhysicalDevicePresentationSupport
// to check whether a queue family of a physical device supports image presentation.
func VulkanSupported() bool {
	return glfwbool(( /*line :33:18*/_Cfunc_glfwVulkanSupported /*line :33:38*/)())
}

// GetVulkanGetInstanceProcAddress returns the function pointer used to find Vulkan core or
// extension functions. The return value of this function can be passed to the Vulkan library.
//
// Note that this function does not work the same way as the glfwGetInstanceProcAddress.
func GetVulkanGetInstanceProcAddress() unsafe.Pointer {
	return ( /*line :41:9*/_Cfunc_getVulkanProcAddr /*line :41:27*/)()
}

// GetRequiredInstanceExtensions returns a slice of Vulkan instance extension names required
// by GLFW for creating Vulkan surfaces for GLFW windows. If successful, the list will always
// contain VK_KHR_surface, so if you don't require any additional extensions you can pass this list
// directly to the VkInstanceCreateInfo struct.
//
// If Vulkan is not available on the machine, this function returns nil. Call
// VulkanSupported to check whether Vulkan is available.
//
// If Vulkan is available but no set of extensions allowing window surface creation was found, this
// function returns nil. You may still use Vulkan for off-screen rendering and compute work.
func (window *Window) GetRequiredInstanceExtensions() []string {
	var count  /*line :55:12*/_Ctype_uint32_t /*line :55:22*/
	strarr := ( /*line :56:12*/_Cfunc_glfwGetRequiredInstanceExtensions /*line :56:46*/)(&count)
	if count == 0 {
		return nil
	}

	extensions := make([]string, count)
	for i := uint(0); i < uint(count); i++ {
		extensions[i] = ( /*line :63:19*/_Cfunc_GoString /*line :63:28*/)(func() *_Ctype_char{ _cgo0 := /*line :63:46*/strarr; var _cgo1 _Ctype_uint = _Ctype_uint /*line :63:60*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :63:64*/_Cfunc_getArrayIndex(_cgo0, _cgo1); }())
	}
	return extensions
}

// CreateWindowSurface creates a Vulkan surface for this window.
func (window *Window) CreateWindowSurface(instance interface{}, allocCallbacks unsafe.Pointer) (surface uintptr, err error) {
	if instance == nil {
		return 0, errors.New("vulkan: instance is nil")
	}
	val := reflect.ValueOf(instance)
	if val.Kind() != reflect.Ptr {
		return 0, fmt.Errorf("vulkan: instance is not a VkInstance (expected kind Ptr, got %s)", val.Kind())
	}
	var vulkanSurface  /*line :77:20*/_Ctype_VkSurfaceKHR /*line :77:34*/
	ret := func() _Ctype_VkResult{ _cgo0 := /*line :79:3*/(_Ctype_VkInstance /*line :79:16*/)(unsafe.Pointer(reflect.ValueOf(instance).Pointer())); _cgo1 := /*line :79:72*/window.data; _cgo2 := /*line :80:3*/(*_Ctype_VkAllocationCallbacks /*line :80:28*/)(allocCallbacks); var _cgo3 *_Ctype_VkSurfaceKHR = /*line :80:47*/(*_Ctype_VkSurfaceKHR /*line :80:63*/)(unsafe.Pointer(&vulkanSurface)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); return /*line :80:97*/_Cfunc_glfwCreateWindowSurface(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if ret != ( /*line :81:12*/_Ciconst_VK_SUCCESS /*line :81:23*/) {
		return 0, fmt.Errorf("vulkan: error creating window surface: %d", ret)
	}
	return uintptr(unsafe.Pointer(&vulkanSurface)), nil
}

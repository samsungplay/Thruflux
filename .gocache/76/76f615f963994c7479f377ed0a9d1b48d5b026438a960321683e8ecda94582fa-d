// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/parkmin/go/pkg/mod/github.com/go-gl/glfw/v3.3/glfw@v0.0.0-20240506104042-037f3cc74f2a/util.go:1:1
package glfw; import _cgo_unsafe "unsafe"

//#include <stdlib.h>
//#define GLFW_INCLUDE_NONE
//#include "glfw/include/GLFW/glfw3.h"
import _ "unsafe"

import (
	"image"
	"image/draw"
)

func glfwbool(b  /*line :13:17*/_Ctype_int /*line :13:22*/) bool {
	return b ==  /*line :14:14*/_Ctype_int /*line :14:19*/(True)
}

func bytes(origin []byte) (pointer *uint8, free func()) {
	n := len(origin)
	if n == 0 {
		return nil, func() {}
	}

	ptr := func() _cgo_unsafe.Pointer{ _cgo0 := /*line :23:18*/origin; _cgoCheckPointer(_cgo0, nil); return /*line :23:25*/_Cfunc_CBytes(_cgo0); }()
	return (*uint8)(ptr), func() { func() { _cgo0 := /*line :24:40*/ptr; _cgoCheckPointer(_cgo0, nil); /*line :24:44*/_Cfunc_free(_cgo0); }() }
}

// imageToGLFW converts img to be compatible with C.GLFWimage.
func imageToGLFW(img image.Image) (r  /*line :28:38*/_Ctype_GLFWimage /*line :28:49*/, free func()) {
	b := img.Bounds()

	r.width =  /*line :31:12*/_Ctype_int /*line :31:17*/(b.Dx())
	r.height =  /*line :32:13*/_Ctype_int /*line :32:18*/(b.Dy())

	var pixels []byte
	if m, ok := img.(*image.NRGBA); ok && m.Stride == b.Dx()*4 {
		pixels = m.Pix[:m.PixOffset(m.Rect.Min.X, m.Rect.Max.Y)]
	} else {
		m := image.NewNRGBA(image.Rect(0, 0, b.Dx(), b.Dy()))
		draw.Draw(m, m.Bounds(), img, b.Min, draw.Src)
		pixels = m.Pix
	}

	pix, free := bytes(pixels)
	r.pixels = (* /*line :44:15*/_Ctype_uchar /*line :44:22*/)(pix)
	return r, free
}
